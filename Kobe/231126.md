# 메모리의 주소 공간 🧑‍💻

"메모리에 저장된 정보의 위치는 주소로 나타낼 수 있습니다."
사실 이 주소에는 두 종류가 있습니다.
바로 "물리 주소"와 "논리 주소"입니다.

**"물리주소"** 는 메모리 하드웨어가 사용하는 주소이고, **"논리 주소"** 는 CPU와 실행 중인 프로그램이 사용하는 주소입니다.

# 1️⃣ 물리 주소와 논리 주소.

CPU와 메모리에 저장되어 실행중인 프로그램은 메모리 몇 번지에 무엇이 저장되어 있는지 다 알지 못합니다.

그 이유는 메모리에 저장된 정보는 시시각각 변하기 때문입니다.
메모리에는 새롭게 실행되는 프로그램이 적재되고, 실행이 끝난 프로그램은 삭제됩니다.

게다가 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소가 달라질 수 있습니다.
1500번지에 적재되었던 프로그램을 다시 실행하면 3000번지, 또 다시 실행하면 2700번지에 적재될 수 있습니다.
이런 상황에서 CPU와 실행 중인 프로그램이 현재 메모리 몇 번지에 무엇이 저장되어 있는지 모조리 알고 있기란 어렵습니다.

**주소**에는 **메모리**가 **사용**하는 **"물리 주소"** 가 있고, **CPU**와 **실행 중인 프로그램**이 **사용**하는 **"논리 주소"** 가 있습니다.

메모리가 사용하는 **"물리 주소(physical address)"** 는 말 그대로 정보가 실제로 저장된 하드웨어상의 주소를 의미합니다.

반면 CPU와 실행 중인 프로그램이 사용하는 **"논리 주소(logical address)"** 는 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소를 의미합니다.

예를 들어 현재 메모리에 메모장, 게임, 인터넷 브라우저 프로그램이 적재되어 있다고 가정해 보겠습니다.

메모장, 게임, 인터넷 브라우저 프로그램은 현재 다른 프로그램들이 메모리 몇 번지에 저장되어 있는지, 다시 말해 다른 프로그램들의 물리 주소가 무엇인지 굳이 알 필요가 없습니다.

새로운 프로그램이 언제든 적재될 수 있고, 실행되지 않는 프로그램은 언제든 메모리에서 사라질 수 있기 때문입니다.

그래서 메모장, 게임, 인터넷 브라우저는 모두 물리 주소가 아닌 0번지부터 시작하는 자신만을 위한 주소인 논리 주소를 가지고 있습니다.

예를 들어, '10번지'라는 주소는 메모장에도, 게임에도, 인터넷 브라우저에도 논리 주소로써 존재할 수 있습니다.

프로그램마다 같은 논리 주소가 얼마든지 있을 수 있다는 뜻입니다.
그리고 CPU는 이 논리 주소를 받아들이고, 해석하고, 연산합니다.

정리하면, 메모리가 사용하는 주소는 하드웨어상의 실제 주소인 물리 주소이고, CPU와 실행 중인 프로그램이 사용하는 주소는 각각의 프로그램에 부여된 논리 주소입니다.

그런데 CPU가 이해하는 주소가 논리 주소라고는 해도 CPU가 메모리와 상호작용하려면 논리 주소와 물리 주소 간의 변환이 이루어져야 합니다.

논리 주소와 물리 주소 간에 어떠한 변환도 이루어지지 않는다면 CPU와 메모리는 서로 이해할 수 없는 주소 체계를 가지고 각자 다른 이야기만 할 뿐 결코 상호작용할 수 없습니다.

논리 주소와 물리 주소 간의 변환은 CPU와 주소 버스 사이에 위치한 **메모리 관리 장치(MMU: Memory Management Unit)** 라는 하드웨어에 의해 수행됩니다.

MMU는 CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환합니다.

예를 들어 현재 베이스 레지스터에 15000이 저장되어있고 CPU가 발생시킨 논리 주소가 100번지라면 이 논리 주소는 물리 주소 15100번지(100+15000)로 변환됩니다.

물리주소 15000번지부터 적재된 프로그램 A의 논리 주소 100번지에는 이렇게 접근이 가능한 것입니다.

**베이스 레지스터**는 프로그램의 가장 작은 물리 주소, 즉 프로그램의 첫 물리 주소를 저장하는 셈이고, **논리 주소**는 프로그램의 시작점으로부터 떨어진 거리인 셈입니다.

# 2️⃣ 메모리 보호 기법.

메모장의 프로그램의 물리 주소가 1000번지부터 1999번지, 인터넷 브라우저 프로그램의 물리 주소가 2000번지부터 2999번지, 게임 프로그램의 물리 주소가 3000번지부터 3999번지라고 가정해 보겠습니다.

만약 메모장 프로그램 명령어 중 '(논리 주소) 1500번지에 숫자 100을 저장하라'와 같은 명령어가 있다면 숫자 100은 어떤 물리 주소에 저장될까요? 이 명령어는 실행되어도 안전할까요?

짐작하겠지만, 위와 같은 명령어들은 실행되어서는 안 됩니다.

프로그램의 논리 주소 영역을 벗어났기 때문입니다.

위 명령어어가 실행된다면 메모장 프로그램 명령어는 애꿏은 인터넷 브라우저 프로그램에 숫자를 저장할 것 입니다.

이렇게 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험하기 때문에 논리 주소 범위를 벗어나는 명령어 실행을 방지하고 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호할 방법이 필요합니다.

이는 **한계 레지스터(limit register)** 라는 레지스터가 담당합니다.

베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한다면, 한계 레지스터는 논리 주소의 최대 크기를 저장합니다.
즉, 프로그램의 물리 주소 범위는 베이스 레지스터 값 이상, 베이스 레지스터 값 + 한계 레지스터 값 미만이 됩니다.

CPU가 접근하려는 논리 주소는 한계 레지스터가 저장한 값보다 커서는 안 됩니다.
한계 레지스터 보다 높은 주소 값에 접근하는 것은 곧 프로그램의 범위에 벗어난 메모리 공간에 접근하는 것과 같기 때문입니다.

베이스 레지스터에 100, 한계 레지스터에 150이 저장되어 있다고 해 봅시다.
이는 물리 주소 시작점이 100번지, 프로그램의 크기(논리 주소의 최대 크기)는 150임을 의미합니다.
따라서 이 프로그램은 150번지를 넘어서는 논리 주소를 가질 수 없습니다.

CPU는 메모리에 접근하기 전에 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지를 항상 검사합니다.
만약 CPU가 한계 레지스터보다 높은 논리 주소에 접근하려고 하면 인터럽트(트랩)를 발생시켜 실행을 중단합니다.

이러한 방식으로 실행 중인 프로그램의 독립적인 실행 공간을 확보하고 하나의 프로그램이 다른 프로그램을 침범하지 못하게 보호할 수 있습니다.

# 💯 메모리의 주소 공간 마무리.

## ✅ 5가지 키워드로 정리하는 핵심 포인트.

- **물리 주소**는 메모리 하드웨어상의 주소이고, **논리 주소**는 CPU와 실행 중인 프로그램이 사용하는 주소입니다.
- **MMU**는 논리 주소를 물리 주소로 변환합니다.
- **베이스 레지스터**는 프로그램의 첫 물리 주소를 지정합니다.
- **한계 레지스터**는 실행 중인 프로그램의 논리 주소의 최대 크기를 저장합니다.
