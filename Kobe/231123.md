# 명령어의 구조.

기계어나 어셈블리어를 이루는 하나하나가 명령어입니다.

이번에는 명령어를 자세히 들여다보며 연산 코드, 오퍼랜드, 주소 지정 방식에 대해 알아봅시다!

# 1️⃣ 연산 코드와 오퍼랜드.

**명령어**는 **'무엇을 대상으로, 어떤 작동을 수행하라'** 는 구조로 되어 있습니다.
**명령어**는 **연산 코드**와 **오퍼랜드**로 구성되어 있습니다.

**"명령어가 수행할 연산"** 을 **연산 코드(operation code)** 라고 합니다.
**"연산에 사용할 데이터가 저장된 위치"** 를 **오퍼랜드(operand)** 라고 합니다.

연산 코드는 **연산자**, 오퍼랜드는 **피연산자**라고도 부릅니다.

연산 코드가 담기는 영역을 **연산 코드 필드** 라고 부릅니다.
오퍼랜드가 담기는 영역을 **오퍼랜드 필드** 라고 부릅니다.

**기계어**와 **어셈블리어** 또한 **명령어**이기 때문에 **연산 코드**와 **오퍼랜드**로 구성되어 있습니다.

```assembler
push   rbp
mov    rbp, rsp
mov    DWORD PTR [rbp-4], 1
mov    DWORD PTR [rbp-8], 2
mov    edx, DWORD PTR [rbp-4]
mov    eax, DWORD PTR [rbp-8]
add    eax, edx
mov    DWORD PTR [rbp-12], eax
mov    eax, 0
pop    rbp
ret
```

앞쪽에 위치한 코드가 연산 코드 뒤쪽에 위치한 코드가 오퍼랜드입니다.

# 2️⃣ 오퍼랜드(Operand)

명령어는 연산 코드와 오퍼랜드로 이루어집니다.

**오퍼랜드**는 '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치'를 의미합니다.
그래서 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있습니다.

다만 오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담깁니다.
그래서 오퍼랜드 필드를 **주소 필드**라고 부르기도 합니다.

오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개만 있을 수도 있고, 두 개 또는 세 개 등 여러 개가 있을 수도 있습니다.

```assembler
mov    eax, 0 -> 오퍼랜드가 두 개인 경우
pop    rbp    -> 오퍼랜드가 한 개인 경우
ret           -> 오퍼랜드가 없는 경우
```

오퍼랜드가 하나도 없는 명령어를 **"0-주소 명령어"** 라고 하고,
오퍼랜드가 하나인 명령어를 **"1-주소 명령어"**, 두 개인 명령어를 **"2-주소 명령어"**, 세 개인 명령어를 **"3-주소 명령어"** 라고 합니다.

# 3️⃣ 연산 코드

**연산 코드**는 명령어가 수행할 연산을 의미합니다.

연산 코드 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있습니다.

1. 대아토 전송.
2. 산술/논리 연산.
3. 제어 흐름 변경.
4. 입출력 제어.

## ✅ 대표적인 연산 코드.

명령어의 종류와 생김새는 CPU마다 다르기 때문에 연산 코드의 종류와 생김새 또한 CPU마다 다릅니다.

지금부터 설명할 내용은 대부분의 CPU가 공통으로 이해하는 대표적인 연산 코드의 종류 정도로만 이해해도 무방합니다.

### 1. 데이터 전송.

- MOVE: 데이터를 옮겨라.
- STORE: 메모리에 저장하라.
- LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라.
- PUSH: 스택에 데이터를 저장하라.
- POP: 스택의 최상단 데이터를 가져와라.

### 2. 산술/논리 연산.

- ADD / SUBTRACT / MULTIPLY / DIVIDE: 덧셈 / 뺄셈 / 곱셉 / 나눗셈을 수행하라.
- INCREMENT / DECREMENT: 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라.
- AND / OR / NOT: AND / OR / NOT 연산을 수행하라.
- COMPARE: 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라.

### 3. 제어 흐름 변경.

- JUMP: 특정 주소로 실행 순서를 옮겨라.
- CONDITIONALJUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라.
- HALT: 프로그램의 실행을 멈춰라.
- CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라.
- RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라.

### 4. 입출력 제어

- READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라.
- WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라.
- START IO: 입출력 장치를 시작하라.
- TEST IO: 입출력 장치의 상태를 확인하라.

# 4️⃣ 주소 지정 방식

저는 스스로 이런 의문이 들었습니다.

"그냥 오퍼랜드 필드에 연산 코드랑 연산 코드에 사용될 데이터를 넣으면 더 편하지 않을까?"

이 의문에 대해서는 **명령어의 길이** 로 인하여 **오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 경우가 많다.** 로 대답할 수 있을 것 같습니다.

조금 더 풀어서 설명해 보겠습니다.

하나의 명령어가 n비트로 구성되어 있고, 그중 연산 코드 필드가 m비트라고 가정해 봅시다.

이때 오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할지라도 오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺀 n-m비트가 됩니다.

2-주소 명령어, 3-주소 명령어라면 오퍼랜드 필드의 크기는 더욱 작아질 것 입니다.

가령 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드당 6비트 정도 밖에 남지 않습니다.
즉, 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2⁶개밖에 되지 않습니다.

- 2-주소 명령어에서 표현할 수 있는 데이터의 크기: 2⁶(64)

그리고 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 3-주소 명령어에서는 오퍼랜드 필드당 4비트 정도밖에 남지 않았습니다. 이 경우 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2⁴개 밖에 없습니다.

- 3-주소 명령어에서 표현할 수 있는 데이터의 크기: 2⁴(16)

하지만 만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커집니다.

예를 들어 한 주소에 16비트를 저장할 수 있는 메모리가 있다고 가정해 봅시다.

이 메모리 안에 데이터를 저장하고, 오퍼랜드 필드 안에 해당 메모리 주소를 명시한다면 표현할 수 있는 정보의 가짓수가 2¹⁶으로 확 커집니다.

오퍼랜드 필드에 메모리 주고사 아닌 레지스터 이름을 명시할 때도 마찬가지 입니다.
이 경우 표현할 수 있는 정보의 가짓수는 해당 레지스터가 저장할 수 있는 공간만큼 커집니다.

연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를 **"유효 주소(effective address)"** 라고 합니다.

이렇듯 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 **"주소 지정 방싱(addressing mode)"** 이라고 합니다.

다시 말해, 주소 지정 방식은 유효 주소를 찾는 방법입니다.

# 5️⃣ 대표적인 주소 지정 방식 5가지

## 1. 즉시 주소 지정 방식.

**"즉시 주소 지정 방식(immediate addressing mode)"** 은 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식입니다.

가장 간단한 형태의 주소 지정 방식입니다.

앞서 언급했듯이 이런 방식은 표현할 수 있는 데이터의 크기가 작아지는 단점이 있지만, 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 이하 설명할 주소 지정 방식들보다 빠릅니다.

## 2. 직접 주소 지정 방식.

**"직접 주소 방식(direect addressing mode)"** 은 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식입니다.

오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었습니다.

다시 말해 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있습니다.

## 3. 레지스터 주소 지정 방식.

**"레지스터 주소 지정 방식(register addressing mode)"** 은 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 지정한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법입니다.

일반적으로 CPU 외부에 있는 메모리에 접근하는것 보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠릅니다.

그러므로 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있습니다.

다만, 레지스터 주소 지정방식은 지접 주소 지정 방식과 비슷한 문제를 공유합니다.

표현할 수 있는 레지스터 크기에 제한이 생길 수 있다는 점입니다.

## 4. 레지스터 간접 주소 지정 방식.

**"레지스터 간접 주소 지정 방식(register indirect addressing mode)"** 은 연산에서 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법입니다.

유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만, 메모리 접근하는 횟수가 한 번으로 줄어든다는 차이이자 장점이 있습니다.

레지스터 간접 주소 지정 방식은 간접 주소 지정 방식보다 빠릅니다.

# 🙌 대표적인 주소 지정 방식 5가지 정리.

연산에 사용할 데이터를 찾는 방법은 **"주소 지정 방식"**, 연산에 사용할 데이터가 저장된 위치를 **"유효주소"** 라고 했습니다.

그리고 대표적인 주소 지정 방식으로는 아래 다섯 가지 방식을 소개했습니다.

각각의 방식이 오퍼랜드 필드에 명시하는 값을 정리해 보면 아래와 같습니다.

- 즉시 주소 지정 방식: 연산에 사용할 데이터
- 직접 주소 지정 방식: 유효 주소(메모리 주소)
- 간접 주소 지정 방식: 유효 주소의 주소
- 레지스터 주소 지정 방식: 유효 주소(레지스터 이름)
- 레지스터 간접 주소 지정 방식: 유효 주소를 저장한 레지스터

이 밖에도 레지스터에 대해 더 공부해야만 이해할 수 있는 중요한 주소 지정 방식들이 있습니다.

# 6️⃣ 스택과 큐.

## 1. 스택(Stack)

**스택(Stack)** 이란 한쪽 끝이 막혀 있는 통과 같은 저장 공간입니다.

한쪽 끝이 막혀 있어서 막혀있지 않은 쪽으로 데이터를 차곡차곡 저장하고, 저장한 자료를 빼낼 때는 마지막으로 저장한 데이터루버 빼냅니다.

스택은 '나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식(후입선출)'이라는 점에서 **LIFO(Last In Fist Out)** 자료 구조라고 합니다.

예를 들어 스택 안에 `1 - 2 - 3 - 4 - 5` 순으로 데이터를 저장하면 데이터를 빼낼 때는 `5 - 4 - 3 - 2 - 1` 순으로 빼낼 수 있습니다.

이때 스택에 새로운 데이터를 저장하는 명령어가 **PUSH**, 스택에 저장된 데이터를 꺼내는 명령어가 **POP** 입니다.

POP 명령어를 수행하면 스택의 최상단에 있는 (Last In), 마지막으로 저장한 데이터부터(First Out) 꺼내게 됩니다.

## 2. 큐(Queue)

스택과 달리 양쪽이 뚫려 있는 통과 같은 저장 공간을 **큐(Queue)** 라고 합니다.

큐는 한쪽으로는 데이터를 저장하고, 다른 한 쪽으로는 먼저 저장한 순서대로 데이터를 빼냅니다.

큐는 '가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식(선입선출)' 이라는 점에서 **FIFO(First In First Out)** 자료 구조라고 부릅니다.

# 💯 명령어의 구조 마무리.

# ✅ 4가지 키워드로 정리하는 핵심 포인트!

- **명령어**는 연산 코드와 오퍼랜드로 구성됩니다.
- **연산 코드**는 명령어가 수행할 연산을 의미합니다.
- **오퍼랜드**는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미합니다.
- **주소 지정 방식**은 연산에 사용할 데이터 위치를 찾는 방법입니다.

---

# 참고 자료 📚

- [iOS에서의 메모리 구조(1) - Stack](https://github.com/devKobe24/TIL/blob/main/TIL/231122_TIL.md)
