# 0과 1로 숫자를 표현하는 방법.

이번 글에서는 컴퓨터가 표현하는 **정보 단위**를 학습하고, **0**과 **1**만으로 숫자를 표현하는 방법을 배워보겠습니다.

## 정보 단위

0과 1을 나타내는 가장 작은 정보 단위를 **비트(bit)** 라고 합니다.

비트는 0 또는 1, 두 가지 정보를 표현할 수 있습니다.

2비트는 네 가지의 상태를 표현할 수 있습니다.

전구를 빗대어 표현하면 아래와 같습니다.

| 전구 번호    | 1번 전구 | 2번 전구 |
| ------------ | -------- | -------- |
| 첫 번째 상태 | off      | off      |
| 두 번째 상태 | off      | on       |
| 세 번째 상태 | on       | off      |
| 네 번째 상태 | on       | on       |

3비트는 여덟 가지 정보를 표현할 수 있습니다.



| 전구 번호 | 1번 전구 | 2번 전구 | 3번 전구 |
| -------- | -------- | -------- | -------- |
| 첫 번째 상태 | off | off | off |
| 두 번째 상태 | on | off | off |
| 세 번째 상태 | off | on | off |
| 네 번째 상태 | off | off | on |
| 다섯 번째 상태 | on | on | off |
| 여섯 번째 상태 | on | off | on |
| 일곱 번째 상태| off | on | on |
| 여덟 번째 상태 | on | on | on |

n 개의 비트로 표현할 수 있는 상태는 2ⁿ 가지 정보를 표현할 수 있습니다.

### 바이트(byte)

여덟 개의 비트를 묶은 단위.

비트보다 한 단계 큰 단위.

1바이트 == 8비트, 2⁸(256)개의 정보를 표현할 수 있다.

### 킬로바이트(kB: kilobyte)

1바이트 1,000개를 묶은 단위 == 1**킬로바이트(kB: kilobyte)**

### 메가바이트(MB: megabyte)

1킬로바이트 1,000개를 묶은 단위 == 1**메가바이트(MB: megabyte)**

### 기가바이트(GB: gigabyte)

1메가바이트 1,000 개를 묶은 단위 == 1**기가바이트(GB: gigabyte)**

### 테라바이트(TB: terabyte)

1기가바이트 1,000개를 묶은 단위를 1**테라바이트(TB: terabyte)**

테라바이트보다 더 큰 단위도 있다.


| 1바이트(1byte) | 8비트(8bit) |
| -------- | -------- |
| 1킬로바이트(1kB) | 1,000바이트(1,000byte) |
| 1메가바이트(1MB)| 1,000킬로바이트(1,000kB) |
| 1기가바이트(1GB) | 1,000 메가바이트(1,000MB) |
| 1테라바이트(1TB) | 1,000기가바이트(1,000GB) |

> NOTE
> 
>> 워드(word)라는 단위도 있다.
>>
>> **워드(word)** 란 CPU가 한 번에 처리할 수 있는 데이터 크기를 의미한다.
>>
>> 만약 CPU가 한 번에 16비트를 처리할 수 있다면 1워드는 16비트가 되고, 한 번에 32비트를 처리할 수 있다면 1워드는 32비트가 되는 것이다.
>> 
>> 이렇게 정의된 워드의 절반 크기를 **하프 워드(half word)**, 1배 크기를 **풀 워드(full word)**, 2배 크기를 **더블 워드(double word)** 라고 부른다.
>> 
>> 워드 크기가 큰 CPU는 한 번에 처리할 수 있는 데이터가 많을 것 이다.
>> 
>> 워드 크기는 CPU마다 다르지만, **현대 컴퓨터**의 워드 크기는 대부분 32비트 또는 64비트이다.
>> 
>> 가령 인텔의 x86 CPU는 32비트 워드 CPU, x64 CPU는 64비트 워드 CPU이다.

## 이진법

수학에서 0과 1만으로 모든 숫자를 표현하는 방법을 **이진법(binary)** 이라고 한다.

이진법을 이용하면 1보다 큰 수도 0과 1만으로 표현할 수 있다.

원리는 간단하다 숫자가 1을 넘어가는 시점에 자리 올림을 하면 된다.

우리가 보통 숫자를 셀 때 9를 넘어가는 시점에 자리를 올림한다.

예를 들어 9 다음이 10, 19 다음이 20.

이는 우리가 일상적으로 **십진법(decimal)** 을 사용하기 때문이다.

십진법은 숫자가 9를 넘어가는 시점에 자리 올림을 하여 0부터 9까지, 열 개의 숫자만으로 모든 수를 표현하는 방법이다.

이와 유사하게 이진법은 숫자가 1을 넘어가는 시점에 자리 올림을 하여 0과 1, 두 개의 숫자만으로 모든 수를 표현한다.

- 이진법으로 표현한 수를 **이진수**, 십진법으로 표현한 수를 **십진수**라고 한다.

컴퓨터에 어떤 숫자를 알려 주려면 십진수가 아닌 이진수로 알려 주어야 한다.

예를 들어, 십진수 2를 컴퓨터에 알려 주려면 이진수로 표현한 10('일영')을 알려주면 된다.

그리고 십진수 8을 컴퓨터에 알려 주려면 이진수로 표현한 1000('일영영영')을 알려주면 된다.

여기서 한 가지 문제가 있다.

숫자만 보고 이게 십진수인지 이진수인지 구분이 안된다.

이처럼 숫자만으로는 이 수가 어떤 진법으로 표현된 수인지 알 수 없다.

이런 혼동을 예방하기 위해 이진수 끝에 아래 첨자 (2)를 붙이거나 이진수 앞에 0b를 붙인다.

전자는 주로 이진수를 수학적으로 표기할 때, 후자는 주로 코드 상에서 이진수를 표기할 때 사용한다.

### 이진수의 음수 표현

0과 1만으로 음수를 표현하는 방법 중 가장 널리 사용되는 방법은 **2의 보수(two's complement)** 를 구해 이 값을 음수로 간주하는 방법이다.

2의 보수의 사전적 의미는 '어떤 수를 그보다 큰 2ⁿ 에서 뺀 값'을 의미한다.

예를 들어 11₍₂₎보다 큰 2의 보수는 11₍₂₎보다 큰 2ⁿ, 즉 100₍₂₎에서 11₍₂₎을 뺀 01₍₂₎이 되는 것이다.

하지만 굳이 이렇게 사전적 의미로 어렵게 이해할 필요는 없다.

2의 보수를 매우 쉽게 표현하자면 '모든 0과 1을 뒤집고, 1을 더한 값'으로 이해하면 된다.

예를 들어 11₍₂₎의 모든 0과 1을 뒤집으면 00₍₂₎이고, 거기에 1을 더한 값은 01₍₂₎입니다.

즉, 11₍₂₎의 2의 보수(음수 표현)는 01₍₂₎이 되는 것이죠.

이런 질문을 할 수도 있습니다.

"-1011₍₂₎을 표현하기 위한 음수로서의 0101₍₂₎과 십진수 5를 표현하기 위한 양수로서의 0101₍₂₎은 똑같이 생겼는데, 이진수만 보고 이게 음수인지 양수인지 어떻게 구분할까?"

실제로 이진수만 봐서는 이게 음수인지 양수인지 구분하기 어렵습니다.

그래서 컴퓨터 내부에서 어떤 수를 다룰 때는 이 수가 양수인지 음수인지를 구분하기 위해 **플래그(flag)** 를 사용합니다.

플래그는 쉽게 말해 부가 정보입니다.

컴퓨터 내부에서 어떤 값을 다룰 때 부가 정보가 필요한 경우 플래그를 사용합니다.

플래그와 관련된 내용은 후에 다룰것 입니다.

지금은 컴퓨터 내부에서 숫자들은 '양수' 혹은 '음수'가 적혀 있는 표시를 들고 다니므로 컴퓨터가 부호를 헷갈릴 일은 없다 정도로만 생각해도 무방합니다.

## 십육진법(hexadecimal)

**십육진법(hexadecimal)** 은 수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식.

그리고 십진수 10, 11, 12, 13, 14, 15를 십육진법 체계에서는 각각 A, B, C, D, E, F로 표기함.

| 십진수 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | ... |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 십육진수 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F | 10 | 11 | ... |

십육진수는 한 글자로 열여섯 종류(0~9, A~F)의 정보를 표현할 수 있으니, 이진수에 비해 더 적은 자릿수로 더 많은 정보를 표현할 수 있음.

십육진수는 숫자 뒤에 아래 첨자 ₍₁₆₎를 붙이거나 숫자 앞에 0x를 붙여 구분함.

전자는 수학적, 후자는 주로 코드상에서 십육진수를 표기할 때 사용되는 방식.

십육진법을 사용하는 주된 이유 중 하나는 이진수를 십육진수로, 십육진수를 이진수로 변환하기 쉽기 때문임.

### 십육진수를 이진수로 변환하기.

십육진수는 한 글자당 열여섯 종류의 숫자를 표현할 수 있다.

십육진수를 이루는 숫자 하나를 이진수로 표현하려면 4비트가 필요하다 (2⁴ = 16)

십육진수를 이진수로 변환하는 간편한 방법 중 하나는 십육진수 한 글자를 4비트의 이진수로 간주하는 것이다.
- 즉, 십육진수를 이루고 있는 각 글자를 따로따로(4개의 숫자로 구성된) 이진수로 변환하고, 그것들을 그대로 이어 붙이면 십육진수가 이진수로 변환됨.
    - 예를 들어 1A2B₍₁₆₎라는 십육진수가 있을 때 각 숫자 1₍₁₆₎, A₍₁₆₎, 2₍₁₆₎, B₍₁₆₎르 이진수로 표현하면 0001₍₂₎, 1010₍₂₎, 0010₍₂₎, 1011₍₂₎ 이다
    - 이 숫자를 그대로 이어 붙인 값, 즉 `0001101000101011₍₂₎`이 1A2B₍₁₆₎를 이진수로 표현한 값이다.

### 이진수를 십육진수로 변환하기.

이진수를 십육진수로 변환할 때는 이진수 숫자를 네 개씩 끊고, 끊어 준 네 개의 숫자를 하나의 십육진수로 변환한 뒤 그대로 이어 붙이면 된다.
- 예를 들어 `11011010₍₂₎`이라는 이진수를 네개씩 끊으면 1101₍₂₎, 0101₍₂₎이고 이는 각각 D₍₁₆₎와 5₍₁₆₎이므로 이를 그대로 이어 붙인 D5₍₁₆₎가 `11011010₍₂₎`를 십육진수로 변환한 수입니다.

## 마무리

### 핵심 포인트
- **비트**는 0과 1 로 표현할 수 있는 가장 작은 정보 단위이다.
- **바이트**, 킬로바이트, 메가바이트, 기가바이트, 테라바이트는 비트보다 더 큰 정보 단위이다.
- **이진법**은 1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 수를 표현하는 방법이다.
- 이진법에서 음수는 **2의 보수**로 표현할 수 있다.
- **십육진법**은 15를 넘어가는 시점에 자리 올림하여 수를 표현하는 방법이다.
