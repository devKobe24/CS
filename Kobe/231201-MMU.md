# 메모리 관리 장치 🧑‍💻

멀티태스킹은 사치품에서 필수품으로 변해왔습니다.
이제는 모든 것이 인터넷에 연결되어 있고, 통신 작업은 계속해서 **백그라운드(background)** 에서 실행(즉 사용자가 실행 중인 프로그램과 더불어 실행된다는 뜻)돼야 하기 때문에 멀티태스킹이 필수입니다.

인덱스 레지스터와 상대 주소 지정이 멀티태스킹에 도움이 될 수 있지만, 이들만으로 충분하지는 않습니다.

프로그램에 버그가 있으면 어떤 일이 벌어질까요?

<img src = "https://github.com/devKobe24/images/blob/main/CS-8.png?raw=true"></br>

예를 들어 사용자 프로그램 2에 버그가 있어서 사용자 프로그램 1이 차지한 메모리를 덮어쓰거나, 심지어 OS의 메모리를 덮어쓴다면 어떤 일이 벌어질까요?

누군가 의도적으로 시스템에 실행 중인 다른 사람의 프로그램을 들여다보거나 변경하는 프로그램을 작성한다면?

각 프로그램을 분리해서 이런 시나리오가 아예 불가능하게 할 수 있으면 정말 좋습니다.

이를 위해 오늘날 대부분의 마이크로프로세서에는 **"메모리 관리 장치(MMU, Memory management unit)"** 가 들어있습니다.

MMU는 아주 복잡한 하드웨어입니다.

MMU가 들어 있는 시스템은 **가상주소(virtual address)** 와 **물리 주소(physical address)** 를 구분합니다.

<img src = "https://github.com/devKobe24/images/blob/main/CS-1-0.png?raw=true"></br>

위 그림처럼 프로그램은 가상 주소를 사용해 작성되고, MMU는 가상 주소를 물리 주소로 변환해줍니다.

MMU와 인덱스 레지스터는 어떤 차이가 있을까요?

MMU의 가상 주소 범위는 물리적 메모리 주소보다 큰 경우가 많습니다.

어떻게 그런 일이 가능할까요?

MMU는 가상 메모리 주소를 두 부분으로 나눕니다.

주소의 하위(LSB쪽) 부분은 물리적 주소 범위와 같습니다.
상위(MSB쪽) 부분은 **"페이지 테이블(page table)"** 이라는 RAM 영역을 통해 주소를 **"변환(translation)"** 합니다.

이 과정을 아래 그림에서 볼 수 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/CS-1-1.png?raw=true"></br>

이 예제에서 메모리는 256바이트 크기의 **페이지(page)** 로 분할됩니다.

페이지 테이블에는 각 페이지가 물리 메모리상에서 차지하는 실제 위치 정보가 들어 있습니다

이를 통해 1000번지(가상 메모리)에서 시작하는 프로그램을 2000번지(물리 메모리)나 다른 곳에 넣을 수 있습니다.
물론 모든 내용이 **"페이지 경계(page boundary)"** 안에 들어 있어야 합니다.

그리고 프로그램 입장에서는 가상 메모리가 연속적인 것처럼 보이지만, 실제 물리 메모리상의 위치는 굳이 연속적일 필요는 없습니다.
심지어 프로그램이 실행되는 도중에 프로그램이 위치한 물리적 메모리 주소가 바뀔 수도 있습니다.

그리고 프로그램들이 서로 협력하는 경우에는 여러 프로그램의 가상 메모리 중 일부가 같은 물리 메모리를 함께 사용하는 **"공유 메모리(shared memory)"** 기능을 제공할 수도 있습니다.

이제 페이지 테이블의 내용이 프로그램 문맥의 일부분이 된다는 사실에 유의하십시오.

지금까지 여러분이 주의를 기울여왔다면 아마도 페이지 테이블이 그냥 메모리의 일부분처럼 보인다는 점을 깨달았을 것입니다.

맞습니다.
그리고 그게 그렇게 간단한 것은 아닙니다.

우리 예제는 16비트 주소를 사용합니다.

64비트 기계를 사용하는 최근 기계를 사용한다면 어떨까요?

주소를 절반씩 두 부분으로 나누면 4GiB의 페이지 테이블이 필요하고, 페이지 크기도 4GiB가 될 것입니다.
하지만 현재도 물리적 메모리가 4GiB 정도밖에 안 되는 시스템이 많이 있으므로 이런 페이지 구성은 그리 쓸모 있지 않습니다.

페이지 크기를 좀 더 작게 만들 수 있을 것입니다.
하지만 페이지 크기를 줄이면 테이블 크기가 늘어납니다.
이를 해결할 해법이 필요합니다.

현대적 프로세서의 MMU는 페이지 테이블 크기가 정해져 있습니다.
전체 **페이지 테이블 항목(page tabke entry)** 은 주 메모리에 저장되거나 주 메모리가 부족한 경우 디스크에 저장됩니다.

MMU는 페이지 테이블 할목 중 일부를 필요로할 때만 자신의 페이지 테이블로 읽어 들입니다.

일부 MMU 설계는 페이지 테이블에 제어 비트를 추가 제공합니다.
이런 제이 비트의 예로 **실행 불가 비트(no execute bit)** 를 들 수 있습니다.

어떤 페이지에 대해 실행 불가 비트가 설정되어 있으면 CPU가 이 페이지에 있는 명령어를 실행할 수 없습니다.
따라서 프로그램이 실수로 자기 데이터를 실행하는 경우를 방지할 수 있습니다.

데이터 부분을 실행할 수 있으면(프로그램을 실행 시점에 마음대로 바꿔 쓸 수 있기 때문에) 보안 문제가 생길 수도 있습니다.
또 다른 일반적인 제어 비트로는 페이지를 **읽기 전용(read only)** 으로 만드는 비트가 있습니다.

프로그램이 물리적 메모리에 연관되지 않는 주소에 접근하면 **페이지 폴트(page fault)** 예외가 발생합니다.
이런 동작은 스택 오버플로 등이 일어날 때 유용하게 쓰일 수 있습니다.

스택 오버플로가 발생하면 스택 범위를 벗어나는 주소에 접근하므로 페이지 폴트가 발생하고, 이 예외가 발생하면 OS는 실행 중인 프로그램을 중단시키는 대신 MMU가 추가 메모리를 할당하게 해서 스택 공간을 늘리고자 사용자 프로그램 실행을 계속할 수 있습니다.

MMU로 인해 폰 노이만 구조와 하버드 구조의 구분이 의미 없어졌습니다.
단일 메모리 버스만 사용하는 폰 노이만 구조의 시스템도 명령어와 데이터 메모리를 분리해 제공할 수 있습니다.
