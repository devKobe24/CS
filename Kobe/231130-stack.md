# Stack 🧑‍💻

함수는 단순한 코드만으로 이뤄지지 않습니다.
함수가 다른 함수를 호출하거나 자기 자신을 호출하는 경우도 자주 있습니다.
이런 경우를 **"재귀(recursion)"** 라고 하며, 재귀는 아주 쓸모가 많습니다.

예제를 살펴보며 말씀드리겠습니다.

핸드폰은 아마도 JPEG(Joint Photographic Experts Group) 압축을 사용해 사진 크기를 감소시킬 것입니다.

이미지 압축이 어떻게 작용하는지 보기 위해 아래의 그림을 살펴봅시다.

<img src = "https://github.com/devKobe24/images/blob/main/CS-1.png?raw=true"></br>

(믿기지 않겠지만 웃는 얼굴 그림입니다 😆)

**재귀적 분할(recursive subdivision)** 을 사용해 압축을 해봅시다.

이미지를 보면 모든 픽셀이 똑같은 색이 아닙니다.
이를 네 부분으로 나누고, 각 부분을 검사합니다.
이 과정을 1픽셀짜리 조각이 생길 때까지 계속합니다.

EXAMPLE CODE 1은 이미지의 일부분을 처리하는 `subdivide` 함수를 보여줍니다.
이 코드는 의사코드(pseudocode)로 되어 있습니다.

`subdivide` 함수는 정사각형의 왼쪽 꼭짓점의 x 및 y 좌표의 크기(size)를 파라미터로 취합니다.('함수가 인자(argument)를 받는다.')

```swift
// EXAMPLE CODE 1
func subdivide(x: Int, y: Int, size: Int) {
    if (size != 1 && "정형 안의 픽셀이 모다 같은 색이 아님") {
        var half = size / 2
        subdivide(x, y, half) // 왼쪽 아래 사분면을 분할
        subdivide(x, y + half, half) // 왼쪽 위 사분면을 분할
        subdivide(x + half, y + half, half) // 오른쪽 위 사분면을 분할
        subdivide(x + half, y, half) // 오른쪽 아래 사분면을 분할
    } else {
        // 정사각형에 대한 정보를 저장
    }
}
```

`subdivide` 함수는 왼쪽 아래 사분면, 왼쪽 위, 오른쪽 위, 오른쪽 아래 순서로 이미지를 색이 똑같은 정사각형 덩어리로 나눕니다.

아래의 그림은 위의 웃는 얼굴을 `subdivide` 함수를 사용해 그리는 방법을 표현한 그림입니다.
분할이 필요한 경우는 회색, 모든 색이 같은 경우는 흰색이나 검은색으로 표시했습니다.

<img src = "https://github.com/devKobe24/images/blob/main/CS-2.png?raw=true"></br>

이 그림에 있는 (추상적) 구조는 컴퓨터 매니아들이 **트리(tree)** 라고 부르고 수학에서 **유향 비순환 그래프(DAG, directed acyclic graph)** 라고 부르는 구조입니다.

이 구조는 화살표를 따라가면서 읽습니다.

이 구조에서 화살표는 더 위쪽을 가리킬 수 없기 때문에 순환(cycle 또는 loop)이 없습니다.

화살표가 뻗어나가지 않는 부분을 **잎 노드(leaf node)** 라고 부르며, 나뭇가지의 맨 끝에 잎이 달려 있는 것처럼 잎 노드도 트리의 맨 마지막에 달려 있습니다.

위 그림을 보면 회색이 아닌 사각형이 40개 있음을 알 수 있습니다.
이 수는 원래 이미지의 픽셀 수인 64개와 비교하면 훨씬 작은 수로, 이 말은 저장해야 할 정보가 줄어든다는 뜻 입니다.
**이것이 바로 압축입니다.**

몇 가지 이유로 인해, 그리고 그리기 쉽다는 이유로 인해 컴퓨터 매니아들은 항상 트리의 뿌리(root)를 맨위에 놓고 트리를 아래쪽으로 자나나게 그립니다.(아마 밖에서 나무를 못봤나봅니다😆)

위 그림에 있는 트리는 각 노드에서 가지가 4개 뻗어나가기 때문에 **쿼드트리(Quadtree)** 라고 부릅니다.
쿼드트리는 **공간 데이터 구조(Spatial data structure)** 에 속합니다.

앞 절에서 본 방법으로 `subdivide` 함수를 구현하면 문제가 생깁니다.
반환값을 저장할 위치가 한군데뿐이기 때문에 `subdivde` 같이 재귀적인 함수는 이미 들어 있던 반환값을 덮어써서 되돌아갈 위치를 잃어버리기 때문에 자기 자신을 호출할 수가 없습니다.

> 📝 Note
> 
> 굳이 재귀가 아니라, 프로그램이 어떤 함수를 호출하고 그 함수가 다른 함수를 호출하기만 해도 처음에 저장해둔 반환 위치가 사라지기 때문에 최초 함수를 호출했던 자리로 돌아갈 없게 됩니다.

재귀 함수가 제대로 작동하려면 반환 주소를 여럿 저장할 수 있어야 합니다.
그리고 함수에서 호출 지점으로 반환할 때 저장된 주소 중 어떤 주소를 사용할지 결정할 수 있어야 합니다.

이미지를 분할하기 위해 `subdivide`를 호출할 때 어떤 패턴을 찾을 수 있는지 살펴봅시다.

트리 아래로 내려갈 수 있으면 항상 아래로 내려가고, 더 이상 아래로 내려갈 화살표가 없는 경우에만 옆에 있는 화살표로 넘어갑니다.
이런 방식을 **"깊이 우선 순회(depth-first traversal)"** 라고 말합니다.

한편 옆에 있는 화살표를 먼저 방문하고 그 후 아래쪽으로 가는 화살표를 방문하는 방식을 **"너비 우선 순회(breadth-first traversal)"** 라고 말합니다.

트리에서 한 수준을 내려갈 때마다 돌아올 위치를 기억해야 합니다.
일단 원래 위치로 돌아오고 나면 저장했던 위치는 더 이상 필요하지 않습니다.

필요한 것은 식당에 쌓아둔 접시 더미 갚은 역할을 할 수 있는 장치입니다.
함수를 호출할 때는 반환 주소를 접시에 넣어서 접시 더미 맨 위에 넣습니다.

함수 호출에서 돌아올 때는 접시 더미 맨 위의 접시를 보고 반환 주소를 결정한 다음, 접시를 제거합니다.
다른 말로 이런 구조를 물건을 쌀하 올린다는 뜻의 **스택(Stack)** 이라고 부릅니다.
좀 더 멋져보이고 싶다면 **LIFO 구조**라고 불러도 됩니다.
**LIFO 구조**는 **"나중에 들어온 것이 먼저 나간다(last in, first out)"** 이라는 뜻입니다.

스택에 물건을 **푸시(push)** 해 넣고, 스택에서 물건을 **팝(pop)** 해서 제거합니다.

스택에 물건을 푸시하는데 더 이상 들어갈 공간이 없으면 이를 **스택 오버플로(stack overflow)** 라고 말합니다.
빈 스택에서 물건을 가져오려고 하는 경우를 **스택 언더플로(stack underflow)** 라고 부릅니다.

이런 일을 소프트웨어에서도 할 수 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/CS-3.png?raw=true"></br>

위 표에서 본 함수 호출 예제에서 모든 함수는 자신이(200번지를 통해) 전달받은 반환 주소를 나중에 사용하기 위해 스택에 넣을 수 있습니다.

다행히 스택이 아주 중요하기 때문에 대부분의 컴퓨터 하드웨어는 스택을 지원합니다.
이런 지원에는 소프트웨어로 스택 오버플로를 항상 검사하지 않아도 되도록 돕는 **한계 레지스터(limit register)** 도 포함됩니다.

스택은 단지 반환 주소만 저장하기 위한 장소는 아닙니다.
subdivide 함수는 프로그램의 속도를 빠르게 하기 위해 이미지의 절반 크기를 계산해 **지역 변수(local variable)** 에 넣고 이 지역 변수에 들어 있는 값을 여덟 번 사용합니다.

함수를 호출할 때 이 지역 변숫값을 그냥 덮어쓰면 안됩니다.
대신, 지역 변수도 스택에 저장해야 합니다.
이렇게 하면 각각의 함수 호출이 서로 독립적이게 됩니다.

이렇게 함수가 호출될 때마다 스택에 저장되는 데이터의 모음을 **스택 프레임(stack frame)** 이라고 부릅니다.

아래의 그림은 `EXAMPLE CODE 1`에 있는 함수로부터 만들어지는 스택 프레임의 예를 보여줍니다.

<img src = "https://github.com/devKobe24/images/blob/main/CS-4.png?raw=true"></br>

진한 검은 선으로 둘러싼 경로를 따라 들어갑니다.
각 함수 호출이 반환 주소와 지역 변수를 포함하는 새로운 스택 프레임을 만든다는 사실을 볼 수 있습니다.

**포스(forth)** 나 **포스트스크립트(PostScript)** 같은 몇몇 언어와 옛날 HP 계산기 몇 가지는 스택 기반 언어입니다.

스택은 컴퓨터 언어에만 한정되지 않습니다.
한국어나 일본어는 스택 기반 언어입니다.
명사(목적어)를 스택에 넣고 그 다음에 오는 동사는 스택에 있는 명사에 적용합니다.

---

### 참고 자료 📚

- [메모리 주소 공간](https://github.com/devKobe24/CS/blob/main/Kobe/231126.md)
